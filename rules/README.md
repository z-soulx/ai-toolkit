# Rules（行为规则）

> AI 行为约束和协议的模板库

## 什么是 Rule？

**Rule** 是约束 AI 在特定场景下行为的协议或规范。与 Skill 不同，Rule 不是"执行任务"，而是"定义规则"。

### Rule vs Skill vs Command

| 类型 | 定义 | 触发方式 | 生命周期 | Token 成本 | 可靠性 | 典型场景 |
|------|------|----------|----------|-----------|--------|----------|
| **Rule** | 行为约束协议 | 自动加载 + 关键词触发 | 持续生效（多轮对话） | ⚠️ 每次对话全文加载 | ✅ 强制机制，不会失效 | 文档维护协议、代码审查规范 |
| **Skill** | 可执行工作流 | 主动调用（`/command`） | 可支持多轮对话 | ✅ 按需加载 | ⚠️ 依赖 AI 记忆，长对话可能失效 | 整理笔记、生成 PDF、PRD 维护 |
| **Command** | Skill 的快捷方式 | 主动调用（`/command`） | 同 Skill | ✅ 按需加载 | ⚠️ 同 Skill | 触发 Skill |
| **手动 @** | 手动引用文件 | 用户 @ 文件路径 | 按需加载，逐渐遗忘 | ✅ 完全按需 | ⚠️ 依赖 AI 记忆，需要定期重新 @ | 偶尔使用的规则 |

### 核心区别

**Rule 的特点**：
- ✅ 自动加载到 AI 上下文（放在 `.claude/` 目录）
- ✅ 支持状态保持（如"目标文件绑定"）
- ✅ 多轮对话中持续生效
- ✅ 通过关键词触发特定行为
- ✅ **强制机制，不会失效**（每次对话都重新加载）
- ⚠️ **每次对话都全文加载**（会占用上下文 token）

**Skill 的特点**：
- ✅ 主动调用才执行
- ✅ 按需加载（节省 token）
- ✅ 可以支持多轮对话（在 SKILL.md 中明确说明）
- ❌ 不能通过关键词自动触发（必须显式调用 `/command`）
- ⚠️ **依赖 AI 记忆，长对话可能失效**
  - 调用后，AI 会尝试记住 Skill 内容
  - 但随着对话变长，上下文会被总结/压缩
  - Skill 的详细规则可能被压缩掉（如"去躁点判定"）
  - 第 20+ 轮对话后，可能完全忘记具体规则

**手动 @ 引用的特点**：
- ✅ 完全按需加载（用户控制）
- ✅ 可以加载完整版（不担心长度）
- ✅ 比启用/禁用文件简单
- ⚠️ 需要手动 @ 文件路径
- ⚠️ 依赖 AI 记忆，需要定期重新 @
- ⚠️ 可能忘记 @（长对话中）

## 什么时候应该创建 Rule？

### 适合创建 Rule 的场景

1. **需要多轮对话中保持状态**
   - 例：PRD 维护（多次迭代变更，需要追溯上下文）
   - 例：代码审查（持续检查多个文件）

2. **需要约束 AI 的默认行为**
   - 例：文档写入协议（控制何时写入、写入什么）
   - 例：代码风格规范（自动检查并提示）

3. **需要在特定项目中持续生效**
   - 例：团队协作规范（所有成员遵守）
   - 例：安全审计规则（持续监控）

4. **有明确的进入/退出机制**
   - 例：`update: file.md` 进入，`stop writing` 退出
   - 例：`enable-review` 进入，`disable-review` 退出

### 不适合创建 Rule 的场景

1. **一次性任务**
   - 例：生成 PDF、整理笔记 → 应该用 Skill

2. **需要主动触发的工作流**
   - 例：代码重构、测试生成 → 应该用 Skill

3. **没有状态保持需求**
   - 例：查询文档、解释代码 → 应该用 Skill

## Rule vs Skill 选择指南

### 方案对比

| 方案 | 触发方式 | Token 成本 | 可靠性 | 适用场景 |
|------|---------|-----------|--------|----------|
| **Rule（启用）** | 关键词（`prd:`） | ⚠️ 每次对话加载 | ✅ 强制机制 | 经常使用 |
| **Skill（调用）** | 显式调用（`/prd`） | ✅ 按需加载 | ⚠️ 长对话可能失效 | 偶尔使用 |
| **手动 @（推荐）** | 手动 @ 文件 | ✅ 完全按需 | ⚠️ 需要定期重新 @ | 灵活控制 |
| **Rule（禁用）** | 手动启用/禁用文件 | ✅ 完全控制 | ✅ 强制机制 | 太麻烦 |

### 方案 1：Rule（启用）

**适合**：
- ✅ 经常使用（几乎每次对话都需要）
- ✅ 需要关键词触发（如 `prd:` 自动进入模式）
- ✅ 规则简短（< 100 行，约 300-400 tokens）
- ✅ 全局约束（如代码风格、安全规范）

**使用方式**：
```bash
cp rules/prd-maintenance/RULE-lite.md \
   your-project/.claude/prd-maintenance.md
```

**示例**：
```
用户：prd: docs/hotel-integration/rujia-incremental
     我们把回调改成异步的

AI：[检测到 prd: 触发，自动进入 PRD 维护模式]
    [更新文档]

用户：再加个重试机制
AI：[继续应用规则]

用户：stop prd
AI：[退出 PRD 维护模式]
```

**成本**：每次对话加载 90 行（约 300-400 tokens）

### 方案 2：Skill（调用）

**适合**：
- ✅ 偶尔使用（不是每次对话都需要）
- ✅ 规则较长（> 100 行）
- ✅ 可以接受显式调用（`/command`）
- ✅ 按需加载（节省 token）

**使用方式**：
```
/prd docs/hotel-integration/rujia-incremental
我们把回调改成异步的
```

**示例**：
```
用户：/prd docs/hotel-integration/rujia-incremental
     我们把回调改成异步的

AI：[加载 prd-maintenance Skill]
    [进入 PRD 维护模式]
    [更新文档]

用户：再加个重试机制
AI：[尝试继续应用规则]

用户：（第 20 轮对话后）增加预付支持
AI：[可能忘记具体规则，需要重新调用 /prd]
```

**成本**：只在调用时加载（约 500 tokens）

**风险**：长对话中可能失效

### 方案 3：手动 @（推荐，灵活）

**适合**：
- ✅ 需要灵活控制（按需加载）
- ✅ 不想每次对话都加载
- ✅ 可以接受手动 @
- ✅ 可以加载完整版（不担心长度）

**使用方式**：
```
@ rules/prd-maintenance/RULE.md
prd: docs/hotel-integration/rujia-incremental
我们把回调改成异步的
```

**示例**：
```
第 1 轮：@ rules/prd-maintenance/RULE.md
        prd: docs/hotel-integration/rujia-incremental
        我们把回调改成异步的
        [AI 加载 RULE.md，应用规则]

第 2-3 轮：再加个重试机制
          [AI 记住规则，继续应用]

第 4 轮：@ rules/prd-maintenance/RULE.md
        增加预付支持
        [重新加载，确保规则不丢失]

第 10 轮：（不 @ 了）修复一个 bug
         [AI 逐渐忘记规则，按默认行为处理]
```

**成本**：完全按需加载（0 token，除非 @）

**优点**：
- ✅ 完全控制
- ✅ 可以加载完整版（465 行）
- ✅ 比启用/禁用文件简单

**缺点**：
- ⚠️ 需要手动 @
- ⚠️ 可能忘记 @（长对话中）

### 方案 4：Rule（手动启用/禁用）

**适合**：
- ✅ 需要完全控制
- ✅ 不介意手动操作

**使用方式**：
```bash
# 需要时启用
cp rules/prd-maintenance/RULE-lite.md .claude/prd-maintenance.md

# 不需要时禁用
rm .claude/prd-maintenance.md
```

**缺点**：太麻烦

### 推荐方案

| 使用频率 | 推荐方案 | 理由 |
|---------|---------|------|
| 经常使用（每天） | Rule（启用） | 300-400 tokens 成本可接受，体验好 |
| 偶尔使用（每周） | 手动 @ | 灵活控制，完全按需 |
| 很少使用（每月） | Skill（调用） | 按需加载，节省 token |

### 什么时候用 Rule？

**核心判断**：你是否愿意为"关键词自动触发"付出"每次对话都加载"的代价？

**适合 Rule**：
- ✅ 经常使用（几乎每次对话都需要）
- ✅ 需要关键词触发（如 `prd:` 自动进入模式）
- ✅ 规则简短（< 100 行，约 300-400 tokens）
- ✅ 全局约束（如代码风格、安全规范）

**示例**：
- 代码风格规范（每次写代码都需要）
- 安全审计规则（持续监控）
- 团队协作规范（所有成员遵守）

### 什么时候用 Skill？

**核心判断**：你是否愿意为"节省 token"付出"显式调用"的代价？

**适合 Skill**：
- ✅ 偶尔使用（不是每次对话都需要）
- ✅ 规则较长（> 100 行）
- ✅ 可以接受显式调用（`/command`）
- ✅ 按需加载（节省 token）

**示例**：
- PRD 维护（偶尔用，规则长）
- 笔记整理（一次性任务）
- 代码重构（按需触发）

### 什么时候用手动 @？

**核心判断**：你是否需要灵活控制，且可以接受手动操作？

**适合手动 @**：
- ✅ 需要灵活控制（按需加载）
- ✅ 不想每次对话都加载
- ✅ 可以接受手动 @
- ✅ 可以加载完整版（不担心长度）

**示例**：
- PRD 维护（偶尔用，需要完整规则）
- 代码审查（按需触发，需要详细规范）
- 文档写入（灵活控制）

### 混合方案

**提供多种方式，让用户选择**：

1. **Rule 版本**（精简版）：
   - 放在 `rules/` 目录
   - 90 行左右，包含核心逻辑
   - 关键词触发（`prd:`）
   - 适合经常使用

2. **Skill 版本**（完整版）：
   - 放在 `skills/` 目录
   - 可以很长，包含详细说明
   - 显式调用（`/prd`）
   - 适合偶尔使用

3. **手动 @ 版本**（完整版）：
   - 放在 `rules/` 目录（RULE.md）
   - 可以很长，包含详细说明
   - 手动 @ 引用
   - 适合灵活控制

用户根据使用频率和偏好选择。

## Rule 的结构规范

每个 Rule 目录必须包含：

```
rules/rule-name/
├── RULE.md       # 完整协议定义（必需）
├── README.md     # 用户文档（必需）
└── examples/     # 使用示例（可选）
    ├── basic.md
    └── advanced.md
```

### RULE.md 内容要求

1. **核心原则**：用简洁的口诀总结规则
2. **触发机制**：明确的进入/退出条件
3. **判定逻辑**：什么情况下执行什么行为
4. **示例**：快速对齐理解

### README.md 内容要求

1. **问题场景**：这个 Rule 解决什么问题
2. **解决方案**：核心原则和机制
3. **使用方式**：如何启用（项目级/全局）
4. **触发方式**：关键词和使用示例
5. **版本选择**：如果有多个版本（Lite/Standard）
6. **Token 成本说明**：Rule 的长度和预估 token 消耗

## 性能考虑

### Token 成本

Rule 会在每次对话开始时全文加载到 AI 上下文：

| Rule 长度 | 预估 Token | 影响 |
|----------|-----------|------|
| < 50 行 | ~150 tokens | 可忽略 |
| 50-100 行 | ~300-400 tokens | 可接受 |
| 100-200 行 | ~600-800 tokens | 需要权衡 |
| > 200 行 | > 1000 tokens | 建议改用 Skill |

**建议**：
- Rule 应该尽可能精简（< 100 行）
- 详细说明、示例、最佳实践放在 README.md（不加载）
- 如果 Rule 超过 200 行，考虑改用 Skill

### 优化策略

1. **提供精简版**：
   - RULE-lite.md（核心逻辑，< 100 行）
   - RULE.md（完整版，包含详细说明）

2. **混合方案**：
   - Rule 版本（精简，关键词触发）
   - Skill 版本（完整，显式调用）

3. **按需启用**：
   - 项目级启用（只在特定项目加载）
   - 临时禁用（添加 .disabled 后缀）

## 如何使用 Rule

### 项目级启用（推荐）

适合特定项目的规则：

```bash
cp rules/rule-name/RULE.md \
   your-project/.claude/rule-name.md
```

Claude Code 会自动加载该规则。

### 全局启用

适合所有项目都需要的规则：

```bash
cp rules/rule-name/RULE.md \
   ~/.claude/rules/rule-name.md
```

所有项目都会应用该规则。

### 临时禁用

```bash
# 重命名文件（添加 .disabled 后缀）
mv your-project/.claude/rule-name.md \
   your-project/.claude/rule-name.md.disabled
```

## 当前 Rules

### prd-maintenance

**场景**：多供应商并行开发 + 敏捷迭代的 PRD 维护

**问题**：
- 多个供应商的 PRD 混在一起，上下文爆炸
- 每次迭代都改 PRD 全文，难以追溯变更历史
- AI 容易被旧版本 PRD 带偏，产生幻觉

**解决方案**：
- 三层结构：Facts（冻结事实）+ Snapshot（当前版本）+ Changelog（变更历史）
- 供应商隔离：每个供应商独立目录，避免上下文混乱
- 渐进演进：小需求单文件 → 中需求拆 Facts → 大需求完全拆分

**版本选择**：
- **RULE-lite.md**（推荐）：90 行精简版，节省上下文
- **RULE.md**：465 行完整版，包含详细示例

**触发关键词**：
- `prd: path/to/prd` - 进入 PRD 维护模式
- `stop prd` - 退出 PRD 维护模式
- `prd-split-facts:` - 拆分 Facts
- `prd-split-full:` - 完全拆分
- `no-record` - 本轮强制不记录

**适用场景**：
- OTA 酒店直连业务（如家增量、华住全量、锦江增量等）
- 多供应商并行开发
- 敏捷迭代，需要追溯上下文

[查看详情](./prd-maintenance/README.md)

### docs-writing-protocol

**场景**：通用文档写入协议

**问题**：
- AI 频繁修改文档，把 bug 修复、重试过程都写进去
- 文档充斥噪声，难以追溯真正的设计变更
- 多次迭代后，上下文混乱

**解决方案**：
- 写入门槛：没点名文件，就不写入
- 去躁点：纠错不记账；改契约/流程/规则/语义，才记账
- 目标文件绑定：多轮对话中持续维护同一文档

**触发关键词**：
- `update: path/to/doc.md` - 进入沉淀模式
- `switch: another.md` - 切换目标
- `stop writing` - 退出沉淀模式
- `no-record` - 本轮强制不记录

**适用场景**：
- OTA 酒店直连业务 PRD（如家增量对接）
- 初期设计 → 多次迭代变更
- 需要追溯上下文，方便 AI 理解历史演进

[查看详情](./docs-writing-protocol/README.md)

## 设计原则

### 1. 最小化原则

Rule 应该尽可能简洁：
- 核心原则用口诀总结（1-2 句）
- 判定逻辑清晰明确
- 避免过度设计

### 2. 明确边界

Rule 必须有明确的：
- 触发条件（何时生效）
- 退出条件（何时停止）
- 作用范围（影响什么）

### 3. 可追溯性

Rule 的行为应该可追溯：
- 记录关键决策
- 提供变更历史
- 支持回滚

### 4. 用户可控

Rule 不应该过度主动：
- 需要用户显式触发（关键词）
- 提供退出机制
- 允许临时禁用

## 贡献指南

### 添加新 Rule

1. 判断是否应该是 Rule（参考"什么时候应该创建 Rule"）
2. 创建目录结构：`rules/rule-name/`
3. 编写 `RULE.md`（完整协议）
4. 编写 `README.md`（用户文档）
5. 在本文档中添加条目
6. 提交 PR

### Rule 命名规范

- 使用 kebab-case（小写 + 连字符）
- 名称应该描述"做什么"，而不是"怎么做"
- 例：`docs-writing-protocol`（好）vs `snapshot-patch-system`（不好）

## License

MIT
